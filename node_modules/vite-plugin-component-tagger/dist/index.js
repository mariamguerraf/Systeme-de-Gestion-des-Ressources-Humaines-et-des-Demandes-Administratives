// Node modules
import path from 'path';
export default function componentTagger(options = {}) {
    // Create the plugin instance
    const plugin = {
        name: 'vite-plugin-component-tagger',
        pluginOptions: {
            // Default options
            enableInProd: options.enableInProd || false,
            extensions: options.extensions || ['.svelte'],
            tagType: options.tagType || 'components'
        }
    };
    let config;
    let projectRoot;
    Object.assign(plugin, {
        configResolved(resolvedConfig) {
            config = resolvedConfig;
            projectRoot = config.root;
        },
        transform(code, id) {
            // Check if file extension matches any of the specified extensions
            if (!plugin.pluginOptions.extensions.some((ext) => id.endsWith(ext))) {
                return null;
            }
            // Skip files from node_modules
            if (id.includes('node_modules')) {
                return null;
            }
            // Skip if in production and not explicitly enabled
            if ((config?.mode === 'production' || config?.isProduction) &&
                !plugin.pluginOptions.enableInProd) {
                return null;
            }
            try {
                // Get the relative path from project root
                const relativePath = path.relative(projectRoot || process.cwd(), id);
                // Get the extension from the file (needed for identifying components)
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                const extension = path.extname(id);
                // Extract component name from the file path
                // For Svelte components, use PascalCase or keep the original name
                const fileName = path.basename(id, path.extname(id));
                const componentName = fileName.charAt(0).toUpperCase() + fileName.slice(1);
                // Process the Svelte file to add component tag and references
                return processComponent(code, relativePath, {
                    tagType: plugin.pluginOptions.tagType,
                    componentName: componentName
                });
            }
            catch (error) {
                console.error(`Error processing ${id}:`, error);
                return null;
            }
        },
        handleHotUpdate(ctx) {
            // Skip files from node_modules
            if (ctx.file.includes('node_modules')) {
                return undefined;
            }
            if (plugin.pluginOptions.extensions.some((ext) => ctx.file.endsWith(ext))) {
                return ctx.modules;
            }
            return undefined;
        }
    });
    return plugin;
}
/**
 * Process a Svelte component to add element references
 */
function processComponent(code, filepath, options) {
    // Split the code into lines for line-by-line processing
    const lines = code.split('\n');
    // Start with the original code
    let result = code;
    // Find the first top-level element if in components mode
    let firstElementInfo = null;
    if (options.tagType === 'components') {
        // Find the first element in the component
        let inScriptBlock = false;
        let inStyleBlock = false;
        for (let i = 0; i < lines.length && !firstElementInfo; i++) {
            const lineNumber = i + 1;
            const line = lines[i];
            // Check for script and style blocks - handling both opening and closing on the same line
            const trimmedLine = line.trim();
            // Handle script blocks
            if (trimmedLine.startsWith('<script')) {
                // Check if the script block is closed on the same line
                if (line.includes('</script>')) {
                    // Skip this line as it contains a complete script block
                    continue;
                }
                inScriptBlock = true;
                continue;
            }
            else if (inScriptBlock) {
                if (line.includes('</script>')) {
                    inScriptBlock = false;
                }
                continue;
            }
            // Handle style blocks
            if (trimmedLine.startsWith('<style')) {
                // Check if the style block is closed on the same line
                if (line.includes('</style>')) {
                    // Skip this line as it contains a complete style block
                    continue;
                }
                inStyleBlock = true;
                continue;
            }
            else if (inStyleBlock) {
                if (line.includes('</style>')) {
                    inStyleBlock = false;
                }
                continue;
            }
            // Skip lines inside script or style blocks
            if (inScriptBlock || inStyleBlock) {
                continue;
            }
            const tags = findTagsInLine(lines[i]);
            if (tags.length > 0) {
                // Take the first tag on the line (leftmost)
                const tag = tags[0];
                // Skip if the tag is likely a component (starts with uppercase) or is self-closing
                if (/^[A-Z]/.test(tag.tagName) || tag.isSelfClosing) {
                    continue;
                }
                firstElementInfo = {
                    lineIndex: i,
                    tag: tag,
                    lineNumber: lineNumber
                };
            }
        }
    }
    // Process each line to find and tag elements
    let processedCode = '';
    for (let i = 0; i < lines.length; i++) {
        const lineNumber = i + 1;
        const line = lines[i];
        let processedLine = line;
        // If in components mode, only process the first element's line
        if (options.tagType === 'components') {
            if (firstElementInfo && i === firstElementInfo.lineIndex) {
                const tag = firstElementInfo.tag;
                // Update line number information
                tag.lineNumber = lineNumber;
                tag.lineEnd = lineNumber + 2; // Use a range of 3 lines by default
                // HTML-escape the filepath to prevent breaking attributes
                const escapedFilepath = filepath
                    .replace(/&/g, '&amp;')
                    .replace(/"/g, '&quot;')
                    .replace(/'/g, '&#39;')
                    .replace(/</g, '&lt;')
                    .replace(/>/g, '&gt;');
                // Create reference attribute with fixed format
                const reference = `data-ref="${escapedFilepath}#L${tag.lineNumber}-${tag.lineEnd}"`;
                // Combine the attributes (only data-ref as per spec)
                const attributes = `${reference}`;
                // Create new tag with reference and component attributes
                const newTag = createTagWithReference(tag.tagName, tag.attrs, attributes, tag.isSelfClosing);
                // Replace tag in the line
                processedLine =
                    processedLine.substring(0, tag.index) +
                        newTag +
                        processedLine.substring(tag.index + tag.fullMatch.length);
            }
        }
        else {
            // Elements mode: Process all tags in this line from end to start to avoid position shifts
            const tags = findTagsInLine(line);
            tags.reverse().forEach((tag) => {
                // Update line number information
                tag.lineNumber = lineNumber;
                tag.lineEnd = lineNumber + 2; // Use a range of 3 lines by default
                // HTML-escape the filepath to prevent breaking attributes
                const escapedFilepath = filepath
                    .replace(/&/g, '&amp;')
                    .replace(/"/g, '&quot;')
                    .replace(/'/g, '&#39;')
                    .replace(/</g, '&lt;')
                    .replace(/>/g, '&gt;');
                // Create reference attribute with fixed format
                const reference = `data-ref="${escapedFilepath}#L${tag.lineNumber}-${tag.lineEnd}"`;
                // Create new tag with reference attribute
                const newTag = createTagWithReference(tag.tagName, tag.attrs, reference, tag.isSelfClosing);
                // Replace tag in the line
                processedLine =
                    processedLine.substring(0, tag.index) +
                        newTag +
                        processedLine.substring(tag.index + tag.fullMatch.length);
            });
        }
        // Add processed line to result
        processedCode += processedLine + '\n';
    }
    // Update result with processed code (remove trailing newline)
    if (processedCode.length > 0) {
        result = processedCode.slice(0, -1);
    }
    return { code: result };
}
/**
 * Remove script, style, and svelte: special tags from code
 * NOTE: Currently unused but kept for future reference
 */
/*
function removeSpecialTags(code: string): string {
    return code
        .replace(/<script[\s\S]*?<\/script>/g, '')
        .replace(/<style[\s\S]*?<\/style>/g, '')
        .replace(/<svelte:[^>]*>[\s\S]*?<\/svelte:[^>]*>/g, '')
        .replace(/<svelte:[^>]*\/>/g, '')
}
*/
/**
 * Check if a tag should be skipped (special tags like script, style, svelte:, etc.)
 */
function isSpecialTag(tagName) {
    // Normalize the tag name to lowercase for comparison
    const normalizedTagName = tagName.toLowerCase();
    return (normalizedTagName === 'script' ||
        normalizedTagName === 'style' ||
        normalizedTagName === 'head' ||
        normalizedTagName === 'meta' ||
        normalizedTagName === 'title' ||
        normalizedTagName === 'link' ||
        normalizedTagName.startsWith('svelte:') ||
        normalizedTagName.startsWith('/') ||
        normalizedTagName.startsWith('!--') || // HTML comments
        normalizedTagName.startsWith('!doctype') || // DOCTYPE declarations
        normalizedTagName === '' // Empty tags
    );
}
/**
 * Find all valid HTML tags in a line of code
 */
function findTagsInLine(line) {
    // Find HTML-like tags, including custom elements with namespaces and dashes (for web components)
    const tagRegex = /<([a-zA-Z][a-zA-Z0-9\-:]*(?:[-:]?[a-zA-Z][a-zA-Z0-9\-:]*)*)([^>]*?)(\s*\/)?>|<!--[\s\S]*?-->|<!DOCTYPE[^>]*>/gi;
    const tags = [];
    let match;
    tagRegex.lastIndex = 0;
    while ((match = tagRegex.exec(line)) !== null) {
        // Skip if this is a comment or DOCTYPE match
        if (match[0].startsWith('<!--') || match[0].startsWith('<!DOCTYPE')) {
            continue;
        }
        const tagName = match[1] || '';
        const attrs = match[2] || '';
        const selfClosingMark = match[3] || '';
        // Skip special tags and closing tags
        if (!isSpecialTag(tagName)) {
            tags.push({
                tagName,
                attrs,
                fullMatch: match[0],
                index: match.index,
                lineNumber: 0, // Will be set during processing
                lineEnd: 0, // Will be set during processing
                isSelfClosing: selfClosingMark.includes('/') || attrs.trim().endsWith('/')
            });
        }
    }
    return tags;
}
/**
 * Create a new tag with the reference attribute
 */
function createTagWithReference(tagName, attrs, reference, isSelfClosing) {
    // Handle self-closing tags
    if (isSelfClosing) {
        // Remove any existing trailing slash and whitespace
        let cleanedAttrs = attrs.replace(/\s*\/\s*$/, '');
        // Add a space if attributes aren't empty and don't already end with a space
        if (cleanedAttrs && !cleanedAttrs.endsWith(' ')) {
            cleanedAttrs += ' ';
        }
        return `<${tagName} ${cleanedAttrs} ${reference} />`;
    }
    // Regular opening tag - add a space if attributes aren't empty and don't already end with a space
    if (attrs && !attrs.endsWith(' ')) {
        attrs += ' ';
    }
    return `<${tagName} ${attrs} ${reference}>`;
}
